package main

import (
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/ghodss/yaml"
	"github.com/rotisserie/eris"
	"github.com/solo-io/go-utils/log"
	code_generator "github.com/solo-io/solo-kit/pkg/code-generator"
	"github.com/solo-io/solo-kit/pkg/code-generator/cmd"
	"github.com/solo-io/solo-kit/pkg/code-generator/schemagen"
	"github.com/solo-io/solo-kit/pkg/code-generator/schemagen/v1beta1"
	"github.com/solo-io/solo-kit/pkg/code-generator/sk_anyvendor"
	"github.com/solo-io/solo-kit/pkg/code-generator/writer"
	apiextv1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
)

//go:generate go run generate.go
//go:generate ./api/v1/generate.sh
//go:generate ./pkg/api/v1/apiserver/generate.sh

func main() {

	log.Printf("starting generate")

	crdGenerator := NewCRDGenerator()
	validationSchemaOptions, err := crdGenerator.GetValidationSchemaOptions()
	if err != nil {
		log.Fatalf("could not get crd validation schema options! :%v", err)
	}

	if err := cmd.Generate(cmd.GenerateOptions{
		RelativeRoot:       ".",
		CompileProtos:      true,
		SkipGenMocks:       true,
		SkipGeneratedTests: true,
		ExternalImports: &sk_anyvendor.Imports{
			Local: []string{"test/**/*.proto", "api/**/*.proto", sk_anyvendor.SoloKitMatchPattern},
			External: map[string][]string{
				sk_anyvendor.ExtProtoMatcher.Package:           sk_anyvendor.ExtProtoMatcher.Patterns,
				sk_anyvendor.EnvoyValidateProtoMatcher.Package: sk_anyvendor.EnvoyValidateProtoMatcher.Patterns,
			},
		},
		ValidationSchemaOpts: validationSchemaOptions,
	}); err != nil {
		log.Fatalf("generate failed!: %v", err)
	}

	if err := crdGenerator.GenerateCRDs(); err != nil {
		log.Fatalf("crd generate failed! :%v", err)
	}

	log.Printf("finished generating code")
}

const schemagenCrdsDir = "./pkg/code-generator/schemagen/fixtures/crds"
const fileHeader = `// Code generated by solo-kit. DO NOT EDIT.`

var projectConfigurations = []ProjectCRDConfig{
	{
		GroupId: "testing.solo.io",
		Filenames: []string{
			"mock_resource.yaml",
			"complicated_mock_resource.yaml",
		},
		GenerationTimeout: time.Minute * 1,
	},
}

func NewCRDGenerator() *CRDGenerator {
	return &CRDGenerator{
		projectConfigurations: projectConfigurations,
		crdsWithSchemaByFile:  map[string]apiextv1beta1.CustomResourceDefinition{},
	}
}

type ProjectCRDConfig struct {
	GroupId           string
	SkipGeneration    bool
	GenerationTimeout time.Duration
	Filenames         []string
}

type CRDGenerator struct {
	// The configuration per project for schemagen
	projectConfigurations []ProjectCRDConfig

	// The CRDs that we generate during schemagen
	crdsWithSchemaByFile map[string]apiextv1beta1.CustomResourceDefinition
}

func (g *CRDGenerator) GetValidationSchemaOptions() (*schemagen.ValidationSchemaOptions, error) {
	projectSchemaOptions := make(map[string]*schemagen.ProjectValidationSchemaOptions, len(g.projectConfigurations))

	for _, projectConfig := range g.projectConfigurations {
		schemaOptions, err := g.getProjectValidationSchemaOptions(projectConfig)
		if err != nil {
			return nil, err
		}
		projectSchemaOptions[projectConfig.GroupId] = schemaOptions
	}

	return &schemagen.ValidationSchemaOptions{
		ProjectSchemaOptions: projectSchemaOptions,
	}, nil
}

func (g *CRDGenerator) getProjectValidationSchemaOptions(projectConfig ProjectCRDConfig) (*schemagen.ProjectValidationSchemaOptions, error) {
	var schemaOptions []*v1beta1.SchemaOptions

	for _, fileName := range projectConfig.Filenames {
		// Ensure that OnSchemaComplete closure is called with the appropriate file name
		crdFileName := fileName

		crd, err := v1beta1.GetCRDFromFile(filepath.Join(schemagenCrdsDir, crdFileName))
		if err != nil {
			return nil, err
		}

		schemaOptions = append(schemaOptions, &v1beta1.SchemaOptions{
			OriginalCrd: crd,
			OnSchemaComplete: func(crdWithSchema apiextv1beta1.CustomResourceDefinition) error {
				g.crdsWithSchemaByFile[crdFileName] = crdWithSchema
				return nil
			},
		})
	}

	return &schemagen.ProjectValidationSchemaOptions{
		SkipGeneration:          projectConfig.SkipGeneration,
		GenerationTimeout:       projectConfig.GenerationTimeout,
		SchemaGenerationOptions: schemaOptions,
	}, nil

}

func (g *CRDGenerator) GenerateCRDs() error {
	crdWriter := writer.DefaultFileWriter{
		Root:   schemagenCrdsDir,
		Header: fileHeader,
	}

	var crdFiles code_generator.Files
	for _, projectConfig := range g.projectConfigurations {
		if projectConfig.SkipGeneration {
			continue
		}
		for _, fileName := range projectConfig.Filenames {
			crdWithSchema, ok := g.crdsWithSchemaByFile[fileName]
			if !ok {
				return eris.Errorf("Could not find crd for file: %s", fileName)
			}

			fileBytes, err := yaml.Marshal(crdWithSchema)
			if err != nil {
				return err
			}

			crdFiles = append(crdFiles, code_generator.File{
				Filename: generatedFileName(fileName),
				Content:  string(fileBytes),
			})
		}
	}
	return crdWriter.WriteFiles(crdFiles)
}

func generatedFileName(filename string) string {
	fileExt := filepath.Ext(filename)
	return fmt.Sprintf("%s.gen%s", strings.TrimSuffix(filename, fileExt), fileExt)
}
