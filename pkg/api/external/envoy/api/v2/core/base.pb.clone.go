// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: github.com/solo-io/solo-kit/api/external/envoy/api/v2/core/base.proto

package core

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"

	"github.com/solo-io/protoc-gen-ext/pkg/clone"
	"google.golang.org/protobuf/proto"

	github_com_golang_protobuf_ptypes_any "github.com/golang/protobuf/ptypes/any"

	github_com_golang_protobuf_ptypes_struct "github.com/golang/protobuf/ptypes/struct"

	github_com_golang_protobuf_ptypes_wrappers "github.com/golang/protobuf/ptypes/wrappers"

	github_com_solo_io_solo_kit_pkg_api_external_envoy_type "github.com/solo-io/solo-kit/pkg/api/external/envoy/type"

	github_com_solo_io_solo_kit_pkg_api_v1_resources_core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = bytes.Compare
	_ = strings.Compare
	_ = clone.Cloner(nil)
	_ = proto.Message(nil)
)

// Clone function
func (m *Locality) Clone() proto.Message {
	var target *Locality
	if m == nil {
		return target
	}
	target = &Locality{}

	target.Region = m.GetRegion()

	target.Zone = m.GetZone()

	target.SubZone = m.GetSubZone()

	return target
}

// Clone function
func (m *BuildVersion) Clone() proto.Message {
	var target *BuildVersion
	if m == nil {
		return target
	}
	target = &BuildVersion{}

	if h, ok := interface{}(m.GetVersion()).(clone.Cloner); ok {
		target.Version = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.SemanticVersion)
	} else {
		target.Version = proto.Clone(m.GetVersion()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.SemanticVersion)
	}

	if h, ok := interface{}(m.GetMetadata()).(clone.Cloner); ok {
		target.Metadata = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Metadata = proto.Clone(m.GetMetadata()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	return target
}

// Clone function
func (m *Extension) Clone() proto.Message {
	var target *Extension
	if m == nil {
		return target
	}
	target = &Extension{}

	target.Name = m.GetName()

	target.Category = m.GetCategory()

	target.TypeDescriptor = m.GetTypeDescriptor()

	if h, ok := interface{}(m.GetVersion()).(clone.Cloner); ok {
		target.Version = h.Clone().(*BuildVersion)
	} else {
		target.Version = proto.Clone(m.GetVersion()).(*BuildVersion)
	}

	target.Disabled = m.GetDisabled()

	return target
}

// Clone function
func (m *Node) Clone() proto.Message {
	var target *Node
	if m == nil {
		return target
	}
	target = &Node{}

	target.Id = m.GetId()

	target.Cluster = m.GetCluster()

	if h, ok := interface{}(m.GetMetadata()).(clone.Cloner); ok {
		target.Metadata = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Metadata = proto.Clone(m.GetMetadata()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	if h, ok := interface{}(m.GetLocality()).(clone.Cloner); ok {
		target.Locality = h.Clone().(*Locality)
	} else {
		target.Locality = proto.Clone(m.GetLocality()).(*Locality)
	}

	target.BuildVersion = m.GetBuildVersion()

	target.UserAgentName = m.GetUserAgentName()

	if m.GetExtensions() != nil {
		target.Extensions = make([]*Extension, len(m.GetExtensions()))
		for idx, v := range m.GetExtensions() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Extensions[idx] = h.Clone().(*Extension)
			} else {
				target.Extensions[idx] = proto.Clone(v).(*Extension)
			}

		}
	}

	if m.GetClientFeatures() != nil {
		target.ClientFeatures = make([]string, len(m.GetClientFeatures()))
		for idx, v := range m.GetClientFeatures() {

			target.ClientFeatures[idx] = v

		}
	}

	if m.GetListeningAddresses() != nil {
		target.ListeningAddresses = make([]*Address, len(m.GetListeningAddresses()))
		for idx, v := range m.GetListeningAddresses() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ListeningAddresses[idx] = h.Clone().(*Address)
			} else {
				target.ListeningAddresses[idx] = proto.Clone(v).(*Address)
			}

		}
	}

	switch m.UserAgentVersionType.(type) {

	case *Node_UserAgentVersion:

		target.UserAgentVersionType = &Node_UserAgentVersion{
			UserAgentVersion: m.GetUserAgentVersion(),
		}

	case *Node_UserAgentBuildVersion:

		if h, ok := interface{}(m.GetUserAgentBuildVersion()).(clone.Cloner); ok {
			target.UserAgentVersionType = &Node_UserAgentBuildVersion{
				UserAgentBuildVersion: h.Clone().(*BuildVersion),
			}
		} else {
			target.UserAgentVersionType = &Node_UserAgentBuildVersion{
				UserAgentBuildVersion: proto.Clone(m.GetUserAgentBuildVersion()).(*BuildVersion),
			}
		}

	}

	return target
}

// Clone function
func (m *Metadata) Clone() proto.Message {
	var target *Metadata
	if m == nil {
		return target
	}
	target = &Metadata{}

	if m.GetFilterMetadata() != nil {
		target.FilterMetadata = make(map[string]*github_com_golang_protobuf_ptypes_struct.Struct, len(m.GetFilterMetadata()))
		for k, v := range m.GetFilterMetadata() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.FilterMetadata[k] = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
			} else {
				target.FilterMetadata[k] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_struct.Struct)
			}

		}
	}

	return target
}

// Clone function
func (m *RuntimeUInt32) Clone() proto.Message {
	var target *RuntimeUInt32
	if m == nil {
		return target
	}
	target = &RuntimeUInt32{}

	target.DefaultValue = m.GetDefaultValue()

	target.RuntimeKey = m.GetRuntimeKey()

	return target
}

// Clone function
func (m *RuntimeFeatureFlag) Clone() proto.Message {
	var target *RuntimeFeatureFlag
	if m == nil {
		return target
	}
	target = &RuntimeFeatureFlag{}

	if h, ok := interface{}(m.GetDefaultValue()).(clone.Cloner); ok {
		target.DefaultValue = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.DefaultValue = proto.Clone(m.GetDefaultValue()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	target.RuntimeKey = m.GetRuntimeKey()

	return target
}

// Clone function
func (m *HeaderValue) Clone() proto.Message {
	var target *HeaderValue
	if m == nil {
		return target
	}
	target = &HeaderValue{}

	target.Key = m.GetKey()

	target.Value = m.GetValue()

	return target
}

// Clone function
func (m *HeaderValueOption) Clone() proto.Message {
	var target *HeaderValueOption
	if m == nil {
		return target
	}
	target = &HeaderValueOption{}

	if h, ok := interface{}(m.GetAppend()).(clone.Cloner); ok {
		target.Append = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.Append = proto.Clone(m.GetAppend()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	switch m.HeaderOption.(type) {

	case *HeaderValueOption_Header:

		if h, ok := interface{}(m.GetHeader()).(clone.Cloner); ok {
			target.HeaderOption = &HeaderValueOption_Header{
				Header: h.Clone().(*HeaderValue),
			}
		} else {
			target.HeaderOption = &HeaderValueOption_Header{
				Header: proto.Clone(m.GetHeader()).(*HeaderValue),
			}
		}

	case *HeaderValueOption_HeaderSecretRef:

		if h, ok := interface{}(m.GetHeaderSecretRef()).(clone.Cloner); ok {
			target.HeaderOption = &HeaderValueOption_HeaderSecretRef{
				HeaderSecretRef: h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef),
			}
		} else {
			target.HeaderOption = &HeaderValueOption_HeaderSecretRef{
				HeaderSecretRef: proto.Clone(m.GetHeaderSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef),
			}
		}

	}

	return target
}

// Clone function
func (m *HeaderMap) Clone() proto.Message {
	var target *HeaderMap
	if m == nil {
		return target
	}
	target = &HeaderMap{}

	if m.GetHeaders() != nil {
		target.Headers = make([]*HeaderValue, len(m.GetHeaders()))
		for idx, v := range m.GetHeaders() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Headers[idx] = h.Clone().(*HeaderValue)
			} else {
				target.Headers[idx] = proto.Clone(v).(*HeaderValue)
			}

		}
	}

	return target
}

// Clone function
func (m *DataSource) Clone() proto.Message {
	var target *DataSource
	if m == nil {
		return target
	}
	target = &DataSource{}

	switch m.Specifier.(type) {

	case *DataSource_Filename:

		target.Specifier = &DataSource_Filename{
			Filename: m.GetFilename(),
		}

	case *DataSource_InlineBytes:

		if m.GetInlineBytes() != nil {
			newArr := make([]byte, len(m.GetInlineBytes()))
			copy(newArr, m.GetInlineBytes())
			target.Specifier = &DataSource_InlineBytes{
				InlineBytes: newArr,
			}
		} else {
			target.Specifier = &DataSource_InlineBytes{
				InlineBytes: nil,
			}
		}

	case *DataSource_InlineString:

		target.Specifier = &DataSource_InlineString{
			InlineString: m.GetInlineString(),
		}

	}

	return target
}

// Clone function
func (m *RemoteDataSource) Clone() proto.Message {
	var target *RemoteDataSource
	if m == nil {
		return target
	}
	target = &RemoteDataSource{}

	if h, ok := interface{}(m.GetHttpUri()).(clone.Cloner); ok {
		target.HttpUri = h.Clone().(*HttpUri)
	} else {
		target.HttpUri = proto.Clone(m.GetHttpUri()).(*HttpUri)
	}

	target.Sha256 = m.GetSha256()

	return target
}

// Clone function
func (m *AsyncDataSource) Clone() proto.Message {
	var target *AsyncDataSource
	if m == nil {
		return target
	}
	target = &AsyncDataSource{}

	switch m.Specifier.(type) {

	case *AsyncDataSource_Local:

		if h, ok := interface{}(m.GetLocal()).(clone.Cloner); ok {
			target.Specifier = &AsyncDataSource_Local{
				Local: h.Clone().(*DataSource),
			}
		} else {
			target.Specifier = &AsyncDataSource_Local{
				Local: proto.Clone(m.GetLocal()).(*DataSource),
			}
		}

	case *AsyncDataSource_Remote:

		if h, ok := interface{}(m.GetRemote()).(clone.Cloner); ok {
			target.Specifier = &AsyncDataSource_Remote{
				Remote: h.Clone().(*RemoteDataSource),
			}
		} else {
			target.Specifier = &AsyncDataSource_Remote{
				Remote: proto.Clone(m.GetRemote()).(*RemoteDataSource),
			}
		}

	}

	return target
}

// Clone function
func (m *TransportSocket) Clone() proto.Message {
	var target *TransportSocket
	if m == nil {
		return target
	}
	target = &TransportSocket{}

	target.Name = m.GetName()

	switch m.ConfigType.(type) {

	case *TransportSocket_Config:

		if h, ok := interface{}(m.GetConfig()).(clone.Cloner); ok {
			target.ConfigType = &TransportSocket_Config{
				Config: h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct),
			}
		} else {
			target.ConfigType = &TransportSocket_Config{
				Config: proto.Clone(m.GetConfig()).(*github_com_golang_protobuf_ptypes_struct.Struct),
			}
		}

	case *TransportSocket_TypedConfig:

		if h, ok := interface{}(m.GetTypedConfig()).(clone.Cloner); ok {
			target.ConfigType = &TransportSocket_TypedConfig{
				TypedConfig: h.Clone().(*github_com_golang_protobuf_ptypes_any.Any),
			}
		} else {
			target.ConfigType = &TransportSocket_TypedConfig{
				TypedConfig: proto.Clone(m.GetTypedConfig()).(*github_com_golang_protobuf_ptypes_any.Any),
			}
		}

	}

	return target
}

// Clone function
func (m *RuntimeFractionalPercent) Clone() proto.Message {
	var target *RuntimeFractionalPercent
	if m == nil {
		return target
	}
	target = &RuntimeFractionalPercent{}

	if h, ok := interface{}(m.GetDefaultValue()).(clone.Cloner); ok {
		target.DefaultValue = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	} else {
		target.DefaultValue = proto.Clone(m.GetDefaultValue()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	}

	target.RuntimeKey = m.GetRuntimeKey()

	return target
}

// Clone function
func (m *ControlPlane) Clone() proto.Message {
	var target *ControlPlane
	if m == nil {
		return target
	}
	target = &ControlPlane{}

	target.Identifier = m.GetIdentifier()

	return target
}
